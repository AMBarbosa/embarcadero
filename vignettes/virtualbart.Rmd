
---
title: "Using BART with a virtual species!"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
vignette: |
  %\VignetteIndexEntry{virtualbart} %\VignetteEncoding{UTF-8} %\VignetteEngine{knitr::rmarkdown}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
suppressMessages(library(tidyverse))
options(digits=2)

```


# Getting Started

So you're interested in using \texttt{embarcadero} to do species distribution modeling with Bayesian additive regression trees! That's great. BARTs are a powerful way to do machine learning and, while not a new method per se, they are very new for SDMs. 

Most of the core functionality of \texttt{embarcadero} is actually a wrapper for \texttt{dbarts}, which runs the actual BART fitting process. This vignete will show you

1. How to run BARTs
1. Variable importance measures
1. Automated variable selection
1. Partial dependence plots
1. Visualizing the posterior distribution

There's also just going to be some general comments on the process of using BARTs, the challenges to working with them, and some things that are hopefully coming next.

If you want to install, do it using devtools for now:

```{r setup, echo=TRUE}
#devtools::install_github('cjcarlson/embarcadero')
library(embarcadero, quietly = T)
library(dismo, quietly=T)
library(NLMR, quietly = T)
library(raster, quietly = T)
library(virtualspecies, quietly = T)
set.seed(42)
```

Doors are closing; please stand clear of the doors.

# Creating the virtual species

First, let's create an imaginary landscape. We do this using the NLMR package:


```{r}
onelandscape <- function(x) {NLMR::nlm_gaussianfield(nrow = 150,
                                                     ncol = 150,
                                                     rescale = FALSE)}
climate <- stack(lapply(c(1:8), onelandscape))
xnames <- c('x1','x2','x3','x4','x5','x6','x7','x8')
names(climate) <- xnames

plot(climate[[1]],main='An imaginary variable')
```

Next, let's make a species using the 'virtualspecies' package. Our imaginary species will only responds to variables 1-4, making variables 5-8 uninformative predictors (hopefully our model will drop them):

```{r}

# Generate the species' climatic niche

random.sp <- generateRandomSp(climate[[1:4]], 
                              # ^ These are the informative predictors
                              approach="pca",
                              relations='gaussian',
                              species.prevalence=0.5,
                              realistic.sp = TRUE,
                              PA.method='threshold')

# Generate some presences, and some absences, with imperfect detection

sp.points <- sampleOccurrences(random.sp,
                               n=250,
                               type = 'presence-absence',
                               detection.probability = 0.9)

# Extract the associated climate values

occ <- SpatialPoints(sp.points$sample.points[,c('x','y')])
occ.df <- cbind(sp.points$sample.points,
                raster::extract(climate, occ))

# Finally, let's drop the long-lats and the "Real" ground truthed presence-absence values, and just leave behind an "Observed" and the climate data

occ.df <- occ.df[,-c(1:3)]

```

Alright. Now that we have the dataset, let's get to modeling!

# Building a basic BART model

We could easily throw all our data in one model, run it on defaults, make a map, and never think about it again. There's no laws against it.

```{r}
# Check out the data structure
head(occ.df)

# Train the model
sdm <- bart(y.train=occ.df[,'Observed'],
            x.train=occ.df[,xnames],
            keeptrees = TRUE) # It's very important this is set to TRUE

# Model diagnostics
summary(sdm)

# Predict the species distribution!
map <- predict(sdm, climate, quiet=TRUE)

# How's it look?
par(mfrow=c(1,2))
plot(random.sp$pa.raster, main='True distribution')
plot(map, main='Predicted probability')
```

Neat! We have a good-looking model. Can we put a few summary stats on that??

```{r}
# How good is it?
summary(sdm) 
```

Let's compare what the thresholded model looks like:

```{r}
# How's it look?
par(mfrow=c(1,2))
plot(random.sp$pa.raster, main='True distribution')
plot(map>0.42, main='Prediced distribution')
```

OK! Not bad.

## What's going on inside a BART model?

# Variable selection 

We could probably do better. One of the easiest ways is to cut some variables we don't think are performing well. In BART, pushing the models towards a smaller number of trees forces the variables to compete a bit, and preferentially upweights the better ones. We can plot that!

```{r}
# A variable importance diagnostic. What's behaving well?
# This takes a while to run normally! Drop the iter if you want a plot faster with more variance.
varimp.diag(occ.df[,xnames], occ.df[,'Observed'], iter=50, quiet=TRUE)
```

OK. This would suggest that some of the variables, like x5 and x7, are less important while x3 and x4 are more important. But that doesn't give us a concrete list of what to drop. Luckily, embarcadero has a stepwise variable set reduction function. Let's run that, and then retrain the model.

```{r}
# Stepwise variable set reduction
step.model <- variable.step(x.data=occ.df[,xnames], 
                            y.data=occ.df[,'Observed'],
                            quiet=TRUE)
step.model

# Retrain the model
sdm <- bart(x.train=occ.df[, step.model], y.train=occ.df[,'Observed'],
            keeptrees = TRUE)

# Predict the species distribution!
map <- predict(sdm, climate, quiet=TRUE)

# How's it look?
par(mfrow=c(1,2))
plot(random.sp$pa.raster, main='True distribution')
plot(map, main='Predicted probability')
```

# Partial dependence plots with BART

OK. This part involves comparing partials to gbm.

```{r}
partial(sdm, x.vars=c('x4'),
        smooth=5,
        equal=TRUE,
        trace=FALSE)
```

gbm time

```{r}
gbm1 <- gbm.step(data=occ.df, gbm.x = 2:5, gbm.y = 1, 
                 family = "bernoulli",
                 tree.complexity = 5, 
                 learning.rate = 0.01, 
                 bag.fraction = 0.5)
par(mfrow=c(1,1))
gbm.plot(gbm1, variable.no=4, rug=TRUE,
         #main="BRT partial",
         plot.layout=c(1,1))

```